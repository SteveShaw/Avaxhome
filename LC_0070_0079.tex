\documentclass[12pt,a4paper]{article}
\usepackage{charter}
%\usepackage[latin1]{inputenc}
\usepackage[left=1.50cm, right=1.50cm, top=1.20cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{textcomp}
\renewcommand{\baselinestretch}{1.5}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\usepackage{float}
\usepackage{CJKutf8}
\usepackage{textcomp}
\usepackage{hyperref}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,    
%	%   rulecolor=,
%	language=[GNU]C++,
%	basicstyle=\scriptsize,
%	upquote=true,
%	aboveskip={1.5\baselineskip},
%	columns=fixed,
%	showstringspaces=false,
%	extendedchars=false,
%	breaklines=true,
%	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%	frame=single,
%	numbers=left,
%	showtabs=false,
%	showspaces=false,
%	showstringspaces=false,
%	identifierstyle=\ttfamily,
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color[rgb]{0.026,0.112,0.095},
%	stringstyle=\color[rgb]{0.627,0.126,0.941},
%	numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%	%        \lstdefinestyle{C++}{language=C++,style=numbers}?.
%}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,
%	language=C++,
%	captionpos=b,
%	tabsize=3,
%	frame=lines,
%	numbers=left,
%	numberstyle=\tiny,
%	numbersep=5pt,
%	breaklines=true,
%	showstringspaces=false,
%	basicstyle=\footnotesize,
%	%  identifierstyle=\color{magenta},
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color{Darkgreen},
%	stringstyle=\color{red}
%}

\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	aboveskip={1.2\baselineskip},
	breaklines=true,
	frame=lines,
	numbers=left,
	xleftmargin=\parindent,
	language=C++,
	showstringspaces=false,
	basicstyle=\sffamily,%,\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
	breaklines=true,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\lstdefinestyle{customasm}{
	belowcaptionskip=1\baselineskip,
	frame=L,
	xleftmargin=\parindent,
	language=[x86masm]Assembler,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}
\section{70}
Too easy. Skip

\section{71}
\begin{CJK}{UTF8}{gbsn}
这道题让简化给定的路径，光根据题目中给的那一个例子还真不太好总结出规律，应该再加上两个例子 path = ``/a/./b/../c/'', $\Rightarrow$ ``/a/c''和 path = ``/a/./b/c/'', $\Rightarrow$ ``/a/b/c''， 这样我们就可以知道中间是``.''的情况直接去掉，是``..''时删掉它上面挨着的一个路径，而下面的边界条件给的一些情况中可以得知，如果是空的话返回``/''，如果有多个``/''只保留一个。那么我们可以把路径看做是由一个或多个``/''分割开的众多子字符串，把它们分别提取出来一一处理即可
\end{CJK}
\begin{lstlisting}
string simplifyPath( string path ) {
	string res, t;
	stringstream ss( path );
	vector<string> v;
	while ( getline( ss, t, '/' ) ) {
		if ( t == "" || t == "." ) continue;
		if ( t == ".." && !v.empty() ) v.pop_back();
		else if ( t != ".." ) v.push_back( t );
	}
	for ( string s : v ) res += "/" + s;
	return res.empty() ? "/" : res;
}
\end{lstlisting}


\section{72}
\begin{CJK}{UTF8}{gbsn}
这道题让求从一个字符串转变到另一个字符串需要的变换步骤，共有三种变换方式，插入一个字符，删除一个字符，和替换一个字符。根据以往的经验，对于字符串相关的题目十有八九都是用动态规划Dynamic Programming来解，这道题也不例外。这道题我们需要维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。跟以往的DP题目类似，难点还是在于找出递推式，我们可以得到dp数组如下：
\end{CJK}
\par
dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]
\par
dp[i][j] = min( dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1 if word1[i-1] != word2[j-1]
\begin{lstlisting}
int minDistance( string word1, string word2 ) {
	int n1 = word1.size(), n2 = word2.size();
	int dp[n1 + 1][n2 + 1];
	for ( int i = 0; i <= n1; ++i ) dp[i][0] = i;
	for ( int i = 0; i <= n2; ++i ) dp[0][i] = i;
	for ( int i = 1; i <= n1; ++i ) {
		for ( int j = 1; j <= n2; ++j ) {
			if ( word1[i - 1] == word2[j - 1] ) {
				dp[i][j] = dp[i - 1][j - 1];
			}
			else {
				dp[i][j] = min( dp[i - 1][j - 1], min( dp[i - 1][j], dp[i][j - 1] ) ) + 1;
			}
		}
	}
	return dp[n1][n2];
}
\end{lstlisting}

\section{73}
\begin{CJK}{UTF8}{gbsn}
这道题中说的空间复杂度为$O(mn)$的解法自不用多说，直接新建一个和matrix等大小的矩阵，然后一行一行的扫，只要有0，就将新建的矩阵的对应行全赋0，行扫完再扫列，然后把更新完的矩阵赋给matrix即可，这个算法的空间复杂度太高。将其优化到$O(m+n)$的方法是，用一个长度为m的一维数组记录各行中是否有0，用一个长度为n的一维数组记录各列中是否有0，最后直接更新matrix数组即可。这道题的要求是用O(1)的空间，那么我们就不能新建数组，我们考虑就用原数组的第一行第一列来记录各行各列是否有0.
\begin{itemize}
\item 先扫描第一行第一列，如果有0，则将各自的flag设置为true
\item 然后扫描非第一行第一列的整个数组，如果有0，则将对应的第一行和第一列的数字赋0
\item 再次遍历非第一行第一列的整个数组，如果对应的第一行和第一列的数字有一个为0，则将当前值赋0
\item 最后根据第一行第一列的flag来更新第一行第一列
\end{itemize}
\end{CJK}
\begin{lstlisting}
void setZeroes( vector<vector<int> > &matrix ) {
	if ( matrix.empty() || matrix[0].empty() ) return;
	int m = matrix.size(), n = matrix[0].size();
	bool rowZero = false, colZero = false;
	for ( int i = 0; i < m; ++i ) {
		if ( matrix[i][0] == 0 ) colZero = true;
	}
	for ( int i = 0; i < n; ++i ) {
		if ( matrix[0][i] == 0 ) rowZero = true;
	}
	for ( int i = 1; i < m; ++i ) {
		for ( int j = 1; j < n; ++j ) {
			if ( matrix[i][j] == 0 ) {
				matrix[0][j] = 0;
				matrix[i][0] = 0;
			}
		}
	}
	for ( int i = 1; i < m; ++i ) {
		for ( int j = 1; j < n; ++j ) {
			if ( matrix[0][j] == 0 || matrix[i][0] == 0 ) {
				matrix[i][j] = 0;
			}
		}
	}
	if ( rowZero ) {
		for ( int i = 0; i < n; ++i ) matrix[0][i] = 0;
	}
	if ( colZero ) {
		for ( int i = 0; i < m; ++i ) matrix[i][0] = 0;
	}
}
\end{lstlisting}

\section{74}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题要求搜索一个二维矩阵，由于给的矩阵是有序的，所以很自然的想到要用二分查找法，我们可以在第一列上先用一次二分查找法找到目标值所在的行的位置，然后在该行上再用一次二分查找法来找是否存在目标值
\end{CJK}
\begin{lstlisting}
bool searchMatrix( vector<vector<int> > &matrix, int target ) {
	if ( matrix.empty() || matrix[0].empty() ) return false;
	if ( target < matrix[0][0] || target > matrix.back().back() ) return false;
	int left = 0, right = matrix.size() - 1;
	while ( left <= right ) {
		int mid = (left + right) / 2;
		if ( matrix[mid][0] == target ) return true;
		else if ( matrix[mid][0] < target ) left = mid + 1;
		else right = mid - 1;
	}
	int tmp = right;
	left = 0;
	right = matrix[tmp].size() - 1;
	while ( left <= right ) {
		int mid = (left + right) / 2;
		if ( matrix[tmp][mid] == target ) return true;
		else if ( matrix[tmp][mid] < target ) left = mid + 1;
		else right = mid - 1;
	}
	return false;
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
当然这道题也可以使用一次二分查找法，如果我们按S型遍历该二维数组，可以得到一个有序的一维数组，那么我们只需要用一次二分查找法，而关键就在于坐标的转换，如何把二维坐标和一维坐标转换是关键点，把一个长度为n的一维数组转化为$r\times c$的二维数组( $r\times c = n$ )后，那么原一维数组中下标为i的元素将出现在二维数组中的$[i/n][i\%n]$的位置
\end{CJK}
\begin{lstlisting}
bool searchMatrix( vector<vector<int> > &matrix, int target ) {
	if ( matrix.empty() || matrix[0].empty() ) return false;
	if ( target < matrix[0][0] || target > matrix.back().back() ) return false;
	int m = matrix.size(), n = matrix[0].size();
	int left = 0, right = m * n - 1;
	while ( left <= right ) {
		int mid = (left + right) / 2;
		if ( matrix[mid / n][mid % n] == target ) return true;
		else if ( matrix[mid / n][mid % n] < target ) left = mid + 1;
		else right = mid - 1;
	}
	return false;
}
\end{lstlisting}
\end{enumerate}

\section{75}
\begin{CJK}{UTF8}{gbsn}
用双指针来做，分别从原数组的首尾往中心移动。
\begin{itemize}
\item 定义red指针指向开头位置，blue指针指向末尾位置
\item 从头开始遍历原数组，如果遇到0，则交换该值和red指针指向的值，并将red指针后移一位。若遇到2，则交换该值和blue指针指向的值，并将blue指针前移一位。若遇到1，则继续遍历。
\end{itemize}
\end{CJK}
\begin{lstlisting}
void sortColors( int A[], int n ) {
	int red = 0, blue = n - 1;
	for ( int i = 0; i <= blue; ++i ) {
		if ( A[i] == 0 ) {
			swap( A[i], A[red++] );
		}
		else if ( A[i] == 2 ) {
			swap( A[i--], A[blue--] );
		}
	}
}
\end{lstlisting}

\section{76}
\begin{CJK}{UTF8}{gbsn}
这道题的要求是要在$O(n)$的时间度里实现找到这个最小窗口字串，那么暴力搜索Brute Force肯定是不能用的，我们可以考虑哈希表，其中key是T中的字符，value是该字符出现的次数。
\begin{itemize}
\item 我们最开始先扫描一遍T，把对应的字符及其出现的次数存到哈希表中。
\item 然后开始遍历S，遇到T中的字符，就把对应的哈希表中的value减一，直到包含了T中的所有的字符，纪录一个字串并更新最小字串值。
\item 将子窗口的左边界向右移，略掉不在T中的字符，如果某个在T中的字符出现的次数大于哈希表中的value，则也可以跳过该字符。
\end{itemize}
\end{CJK}
\begin{lstlisting}
string minWindow(string S, string T) {
	if (T.size() > S.size()) return "";
	string res = "";
	int left = 0, count = 0, minLen = S.size() + 1;
	unordered_map<char, int> m;
	for (int i = 0; i < T.size(); ++i) {
		if (m.find(T[i]) != m.end()) ++m[T[i]];
		else m[T[i]] = 1;
	}
	for (int right = 0; right < S.size(); ++right) {
		if (m.find(S[right]) != m.end()) {
			--m[S[right]];
			if (m[S[right]] >= 0) ++count;
			while (count == T.size()) {
				if (right - left + 1 < minLen) {
					minLen = right - left + 1;
					res = S.substr(left, minLen);
				}
				if (m.find(S[left]) != m.end()) {
					++m[S[left]];
					if (m[S[left]] > 0) --count;
				}
				++left;
			}
		}
	}
	return res;
}
\end{lstlisting}
\begin{CJK}{UTF8}{gbsn}
哈希表可以直接用个int的数组来代替，因为ASCII只有256个字符，所以用两个大小为256的int数组即可代替哈希表
\end{CJK}
\begin{lstlisting}
string minWindow(string S, string T) {
	if (T.size() > S.size()) return "";
	string res = "";
	int left = 0, count = 0, minLen = S.size() + 1;
	int tm[256] = { 0 }, sm[256] = { 0 };
	for (int i = 0; i < T.size(); ++i) ++tm[T[i]];
	for (int right = 0; right < S.size(); ++right) {
		if (tm[S[right]] != 0) {
			++sm[S[right]];
			if (sm[S[right]] <= tm[S[right]]) ++count;
			while (count == T.size()) {
				if (right - left + 1 < minLen) {
					minLen = right - left + 1;
					res = S.substr(left, minLen);
				}
				if (tm[S[left]] != 0) {
					--sm[S[left]];
					if (sm[S[left]] < tm[S[left]]) --count;
				}
				++left;
			}
		}
	}
	return res;
}
\end{lstlisting}

\section{77}
\begin{CJK}{UTF8}{gbsn}
这道题让求1到n共n个数字里k个数的组合数的所有情况，还是要用深度优先搜索DFS来解，根据以往的经验，像这种要求出所有结果的集合，一般都是用DFS调用递归来解。那么我们建立一个保存最终结果的大集合res，还要定义一个保存每一个组合的小集合out，每次放一个数到out里，如果out里数个数到了k个，则把out保存到最终结果中，否则在下一层中继续调用递归
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	vector<vector<int> > combine(int n, int k) {
		vector<vector<int> > res;
		vector<int> out;
		combineDFS(n, k, 1, out, res);
		return res;
	}
	void combineDFS(int n, int k, int level, vector<int> &out, vector<vector<int> > &res) {
		if (out.size() == k) res.push_back(out);
		else {
			for (int i = level; i <= n; ++i) {
				out.push_back(i);
				combineDFS(n, k, i + 1, out, res);
				out.pop_back();
			}
		}
	}
};
\end{lstlisting}

\section{78}
\begin{CJK}{UTF8}{gbsn}
这道求子集合的问题，由于其要列出所有结果，按照以往的经验，肯定要是要用递归来做。这道题其实它的非递归解法相对来说更简单一点，下面我们先来看非递归的解法，由于题目要求子集合中数字的顺序是非降序排列的，所有我们需要预处理，先给输入数组排序，然后再进一步处理，最开始我在想的时候，是想按照子集的长度由少到多全部写出来，比如子集长度为0的就是空集，空集是任何集合的子集，满足条件，直接加入。下面长度为1的子集，直接一个循环加入所有数字，子集长度为2的话可以用两个循环，但是这种想法到后面就行不通了，因为循环的个数不能无限的增长，所以我们必须换一种思路。我们可以一位一位的网上叠加，比如对于题目中给的例子[1,2,3]来说，最开始是空集，那么我们现在要处理1，就在空集上加1，为[1]，现在我们有两个自己[]和[1]，下面我们来处理2，我们在之前的子集基础上，每个都加个2，可以分别得到[2]，[1, 2]，那么现在所有的子集合为[], [1], [2], [1, 2]，同理处理3的情况可得[3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合了
\end{CJK}
\begin{lstlisting}
vector<vector<int> > subsets(vector<int> &S) {
	vector<vector<int> > res(1);
	sort(S.begin(), S.end());
	for (int i = 0; i < S.size(); ++i) {
		int size = res.size();
		for (int j = 0; j < size; ++j) {
			res.push_back(res[j]);
			res.back().push_back(S[i]);
		}
	}
	return res;
}
\end{lstlisting}
\begin{CJK}{UTF8}{gbsn}
下面来看递归的解法，相当于一种深度优先搜索，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：
\end{CJK}
\begin{lstlisting}
[]        
                   /          \        
                  /            \     
                 /              \
              [1]                []
           /       \           /    \
          /         \         /      \        
       [1 2]       [1]       [2]     []
      /     \     /   \     /   \    / \
  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []
\end{lstlisting}
\begin{lstlisting}
// Recursion
class Solution {
public:
	vector<vector<int> > subsets(vector<int> &S) {
		vector<vector<int> > res;
		vector<int> out;
		sort(S.begin(), S.end());
		getSubsets(S, 0, out, res);
		return res;
	}
	void getSubsets(vector<int> &S, int pos, vector<int> &out, vector<vector<int> > &res) {
		res.push_back(out);
		for (int i = pos; i < S.size(); ++i) {
			out.push_back(S[i]);
			getSubsets(S, i + 1, out, res);
			out.pop_back();
		}
	}
};
\end{lstlisting}

\section{79}
\begin{CJK}{UTF8}{gbsn}
这道题是典型的深度优先遍历DFS的应用，原二维数组就像是一个迷宫，可以上下左右四个方向行走，我们以二维数组中每一个数都作为起点和给定字符串做匹配，我们还需要一个和原数组等大小的visited数组，是bool型的，用来记录当前位置是否已经被访问过，因为题目要求一个cell只能被访问一次。如果二维数组board的当前字符和目标字符串word对应的字符相等，则对其上下左右四个邻字符分别调用DFS的递归函数，只要有一个返回true，那么就表示可以找到对应的字符串，否则就不能找到，
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	bool exist(vector<vector<char> > &board, string word) {
		if (word.empty()) return true;
		if (board.empty() || board[0].empty()) return false;
		vector<vector<bool> > visited(board.size(), vector<bool>(board[0].size(), false));
		for (int i = 0; i < board.size(); ++i) {
			for (int j = 0; j < board[i].size(); ++j) {
				if (search(board, word, 0, i, j, visited)) return true;
			}
		}
		return false;
	}
	bool search(vector<vector<char> > &board, string word, int idx, int i, int j, vector<vector<bool> > &visited) {
		if (idx == word.size()) return true;
		if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[idx]) return false;
		visited[i][j] = true;
		bool res = search(board, word, idx + 1, i - 1, j, visited)
			|| search(board, word, idx + 1, i + 1, j, visited)
			|| search(board, word, idx + 1, i, j - 1, visited)
			|| search(board, word, idx + 1, i, j + 1, visited);
		visited[i][j] = false;
		return res;
	}
};
\end{lstlisting}
\end{document}