\documentclass[12pt,a4paper]{article}
\usepackage{charter}
%\usepackage[latin1]{inputenc}
\usepackage[left=1.50cm, right=1.50cm, top=1.20cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{textcomp}
\renewcommand{\baselinestretch}{1.5}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\usepackage{float}
\usepackage{CJKutf8}
\usepackage{textcomp}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,    
%	%   rulecolor=,
%	language=[GNU]C++,
%	basicstyle=\scriptsize,
%	upquote=true,
%	aboveskip={1.5\baselineskip},
%	columns=fixed,
%	showstringspaces=false,
%	extendedchars=false,
%	breaklines=true,
%	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%	frame=single,
%	numbers=left,
%	showtabs=false,
%	showspaces=false,
%	showstringspaces=false,
%	identifierstyle=\ttfamily,
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color[rgb]{0.026,0.112,0.095},
%	stringstyle=\color[rgb]{0.627,0.126,0.941},
%	numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%	%        \lstdefinestyle{C++}{language=C++,style=numbers}?.
%}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,
%	language=C++,
%	captionpos=b,
%	tabsize=3,
%	frame=lines,
%	numbers=left,
%	numberstyle=\tiny,
%	numbersep=5pt,
%	breaklines=true,
%	showstringspaces=false,
%	basicstyle=\footnotesize,
%	%  identifierstyle=\color{magenta},
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color{Darkgreen},
%	stringstyle=\color{red}
%}

\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	aboveskip={1.2\baselineskip},
	breaklines=true,
	frame=lines,
	numbers=left,
	xleftmargin=\parindent,
	language=C++,
	showstringspaces=false,
	basicstyle=\sffamily,%,\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
	breaklines=true,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\lstdefinestyle{customasm}{
	belowcaptionskip=1\baselineskip,
	frame=L,
	xleftmargin=\parindent,
	language=[x86masm]Assembler,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}
\section{HOW TO}
\subsection{40}
\begin{CJK}{UTF8}{gbsn}
这道题跟之前那道 Combination Sum 组合之和 本质没有区别，只需要改动一点点即可，
之前那道题给定数组中的数字可以重复使用，
而这道题不能重复使用，只需要在之前的基础上修改两个地方即可，
首先在递归的for循环里加上if (i $>$ start \&\& num[i] == num[i - 1]) continue; 
这样可以防止res中出现重复项，
然后就在递归调用combinationSum2DFS里面的参数换成i+1，这样就不会重复使用数组中的数字了
\end{CJK}
\subsection{41}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题让我们找缺失的首个正数，由于限定了O(n)的时间，
所以一般的排序方法都不能用，最开始我没有看到还限制了空间复杂度，
所以想到了用哈希表来解，这个思路很简单，第一遍遍历数组把所有的数都存入哈希表中，
并且找出数组的最大值，下次循环从1开始递增找数字，
哪个数字找不到就返回哪个数字，如果一直找到了最大的数字，则返回最大值+1，
\item
但是上面的解法不是O(1)的时间复杂度，所以我们需要另想一种解法，
既然不能建立新的数组，那么我们只能覆盖原有数组，
我们的思路是把1放在数组第一个位置A[0]，2放在第二个位置A[1]，
即需要把A[i]放在A[A[i] - 1]上，
那么我们遍历整个数组，
如果A[i] != i + 1, 而A[i]为整数且不大于n，另外A[i]不等于A[A[i] - 1]的话，
我们将两者位置调换，如果不满足上述条件直接跳过，
最后我们再遍历一遍数组，如果对应位置上的数不正确则返回正确的数
\end{CJK}
\end{enumerate}

\subsection{42}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道收集雨水的题跟之前的那道 Largest Rectangle in Histogram 直方图中最大的矩形 
有些类似，但是又不太一样，我最先想到的方法有些复杂，
但是也能通过OJ，想法是遍历数组，找到局部最小值，
方法是如果当前值大于或等于前一个值，或者当前值大于后一个值则跳过，
找到了局部最小值后，然后我们首先向左找到左边的最大值，再找右边的最大值，
找右边最大值时要注意当其大于左边最大时时就停止寻找了，
然后算出从左边最大值到右边最大值之间能装的水量，
之后从右边最大值的位置开始继续找局部最小值，以此类推直到遍历完整个数组
\end{CJK}
\item
\begin{CJK}{UTF8}{gbsn}
这种方法是基于动态规划Dynamic Programming的，我们维护一个一维的dp数组，
这个DP算法需要遍历两遍数组，第一遍遍历dp[i]中存入i位置左边的最大值，
然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，
然后跟当前值A[i]相比，如果大于当前值，则将差值存入结果
\end{CJK}
\item
\begin{CJK}{UTF8}{gbsn}
最后我们来看一种只需要遍历一次即可的解法，这个算法需要left和right两个指针分别指向数组的首尾位置，
从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，
则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，
以此类推直至left和right指针重合
\end{CJK}
\end{enumerate}

\subsection{43}
\begin{CJK}{UTF8}{gbsn}
首先我们把每一位相乘，得到一个没有进位的临时结果，
如图中中间的一行红色数字就是临时结果，
然后把临时结果从低位起依次进位。
对于一个m位整数乘以n位整数的结果，最多只有m+n位
\end{CJK}
\begin{center}
\includegraphics[width=0.8\linewidth]{0043.png}
\end{center}
\subsection{44}
\begin{CJK}{UTF8}{gbsn}
外卡匹配和正则匹配最大的区别就是在星号的使用规则上，对于正则匹配来说，星号不能单独存在，前面必须要有一个字符，而星号存在的意义就是表明前面这个字符的个数可以是任意个，包括0个，那么就是说即使前面这个字符并没有在s中出现过也无所谓，只要后面的能匹配上就可以了。而外卡匹配就不是这样的，外卡匹配中的星号跟前面的字符没有半毛钱关系，如果前面的字符没有匹配上，那么直接返回false了，根本不用管星号。而星号存在的作用是可以表示任意的字符串，
当然只是当匹配字符串缺少一些字符的时候起作用，当匹配字符串包含目标字符串没有的字符时，将无法成功匹配。
\end{CJK}
\subsection{45}
\begin{CJK}{UTF8}{gbsn}
这题是之前那道Jump Game 跳跃游戏 的延伸，那题是问能不能到达最后一个数字，而此题只让我们求到达最后一个位置的最少跳跃数，
貌似是默认一定能到达最后位置的? 此题的核心方法还是利用动态规划Dynamic Programming的思想来解，
我们需要两个变量cur和pre分别来保存当前的能到达的最远位置和之前能到达的最远位置，
只要cur未达到最后一个位置则循环继续，pre记录cur的值，如果当前位置i小于等于pre，则更新cur然后i自增1。
更新cur的方法是比较当前的cur和i + A[i]之中的较大值，等i循环到pre的值时，
跳跃的步数加一，如果题目中未说明是否能到达末尾，我们还可以判断此时pre和cur是否相等，
如果相等说明cur没有更新，即无法到达末尾位置，返回$-1$，
\end{CJK}

\subsection{46}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题是求全排列问题，给的输入数组没有重复项，这跟之前的那道 Combinations 组合项 和类似，解法基本相同，
但是不同点在于那道不同的数字顺序只算一种，是一道典型的组合题，而此题是求全排列问题，
还是用递归DFS来求解。这里我们需要用到一个visited数组来标记某个数字是否访问过，
然后在DFS递归函数从的循环应从头开始，而不是从level开始，
这是和 Combinations 组合项 不同的地方，其余思路大体相同
\end{CJK}
\item
\begin{CJK}{UTF8}{gbsn}
递归的写法更简单一些，每次交换num里面的两个数字，经过递归可以生成所有的排列情况
\end{CJK}
\end{enumerate}

\subsection{47}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题是之前那道 Permutations 全排列的延伸，由于输入数组有可能出现重复数字，如果按照之前的算法运算，会有重复排列产生，我们要避免重复的产生，
在递归函数中要判断前面一个数和当前的数是否相等，如果相等，前面的数必须已经使用了，
即对应的visited中的值为1，当前的数字才能使用，否则需要跳过，这样就不会产生重复排列了，
\end{CJK}
\item
\begin{CJK}{UTF8}{gbsn}
还有一种比较简便的方法，在Permutations的基础上稍加修改，
我们用set来保存结果，利用其不会有重复项的特点，然后我们再递归函数中的swap的地方，
判断如果i和start不相同，但是nums[i]和nums[start]相同的情况下跳过，继续下一个循环
\end{CJK}
\end{enumerate}

\subsection{48}
\begin{CJK}{UTF8}{gbsn}
首先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果
\end{CJK}
\[
  \begin{bmatrix}
    1 & 2 & 3  \\
    4 & 5 & 6  \\
	7 & 8 & 9  \\
  \end{bmatrix}
  \rightarrow
  \begin{bmatrix}
    1 & 4 & 7  \\
    2 & 5 & 8  \\
	3 & 6 & 9  \\
  \end{bmatrix}
  \rightarrow
  \begin{bmatrix}
    7 & 4 & 1  \\
    8 & 5 & 2  \\
	9 & 6 & 3  \\
  \end{bmatrix}
\]

\subsection{49}
\begin{CJK}{UTF8}{gbsn}
这道题让我们找出给定字符串集中所有的错位词，所谓的错位词就是两个字符串中字母出现的次数都一样，
只是位置不同，比如abc，bac, cba等它们就互为错位词，
那么我们如何判断两者是否是错位词呢，我们发现如果把错位词的字符顺序重新排列，
那么会得到相同的结果，所以重新排序是判断是否互为错位词的方法，
由于我们还要把所有的错位词都存到一个新的向量中，
所以我们还得知道错位词在原数组中的下标，那么我们可以利用哈希表来把字符和其下标记录起来，那么我们的具体算法为：
\par
用map$<$string, int$>$记录排序后的字符串以及首次出现的位置。
\begin{enumerate}
\item 从strs的第一个元素开始遍历，首先对元素进行排序得到s；
\item 在map里查找s；
\item 若不存在，将s以及该元素的下标存入map；
\item 若存在，首先将第一次出现s时的原始字符串存入结果res，即strs[map[s]]，并将map[s]设置为$-1$（防止下次再存），再将该字符串本身存入结果res；
\item 重复以上1--4步，直到遍历结束。
\end{enumerate}
\end{CJK}

\section{SOLUTION}
\subsection{40}
\subsection{41}
\subsection{42}
\begin{enumerate}
\item
Method 1:
\begin{lstlisting}
int trap( int A[], int n ) {
	int res = 0, left = 0, right = 0, level = 0;
	for ( int i = 1; i < n - 1; ++i ) {
		if ( A[i] >= A[i - 1] || A[i] > A[i + 1] ) continue;
		for ( left = i - 1; left > 0; --left ) {
			if ( A[left] >= A[left - 1] ) break;
		}
		right = i + 1;
		for ( int j = i + 1; j < n; ++j ) {
			if ( A[j] >= A[right] ) {
				right = j;
				if ( A[right] >= A[left] ) break;
			}
		}
		level = min( A[left], A[right] );
		for ( int j = left + 1; j < right; ++j ) {
			if ( level - A[j] > 0 ) res += (level - A[j]);
		}
		i = right;
	}
	return res;
}
\end{lstlisting}
\item
Method 2:
\begin{lstlisting}
int trap( int A[], int n ) {
	int res = 0, mx = 0;
	vector<int> dp( n, 0 );
	for ( int i = 0; i < n; ++i ) {
		dp[i] = mx;
		mx = max( mx, A[i] );
	}
	mx = 0;
	for ( int i = n - 1; i >= 0; --i ) {
		dp[i] = min( dp[i], mx );
		mx = max( mx, A[i] );
		if ( dp[i] - A[i] > 0 ) res += (dp[i] - A[i]);
	}
	return res;
}
\end{lstlisting}
\item
Method 3:
\begin{lstlisting}
int trap( int A[], int n ) {
	int res = 0, left = 0, right = n - 1;
	while ( left < right ) {
		int mn = min( A[left], A[right] );
		if ( A[left] == mn ) {
			++left;
			while ( left < right && A[left] < mn ) {
				res += (mn - A[left]);
				++left;
			}
		}
		else {
			--right;
			while ( left < right && A[right] < mn ) {
				res += (mn - A[right]);
				--right;
			}
		}
	}
	return res;
}
\end{lstlisting}
\end{enumerate}

\subsection{43}
\begin{lstlisting}
string multiply( string num1, string num2 ) {
	string res;
	int n1 = num1.size(), n2 = num2.size();
	int k = n1 + n2 - 2, carry = 0;
	vector<int> v( n1 + n2, 0 );
	for ( int i = 0; i < n1; ++i ) {
		for ( int j = 0; j < n2; ++j ) {
			//add without carry
			v[k - i - j] += (num1[i] - '0') * (num2[j] - '0');
		}
	}
	for ( int i = 0; i < n1 + n2; ++i ) {
		v[i] += carry;
		carry = v[i] / 10;
		v[i] %= 10;
	}
	int i = n1 + n2 - 1;
	while ( v[i] == 0 ) --i; //remove "0" as prefix
	if ( i < 0 ) return "0"; //remove zero
	while ( i >= 0 ) res.push_back( v[i--] + '0' );
	return res;
}
\end{lstlisting}
\subsection{44}
\begin{lstlisting}
bool isMatch( string s, string p ) {
	int m = s.size(), n = p.size();
	vector<vector<bool>> dp( m + 1, vector<bool>( n + 1, false ) );
	dp[0][0] = true;
	for ( int i = 1; i <= n; ++i ) {
		if ( p[i - 1] == '*' ) dp[0][i] = dp[0][i - 1];
	}
	for ( int i = 1; i <= m; ++i ) {
		for ( int j = 1; j <= n; ++j ) {
			if ( p[j - 1] == '*' ) {
				dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
			}
			else {
				dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && dp[i - 1][j - 1];
			}
		}
	}
	return dp[m][n];
}
\end{lstlisting}
\subsection{45}
\begin{lstlisting}
int jump( int A[], int n ) {
	int res = 0, i = 0, cur = 0;
	while ( cur < n - 1 ) {
		int pre = cur;
		while ( i <= pre ) {
			cur = max( cur, i + A[i] );
			++i;
		}
		++res;
		if ( pre == cur ) return -1; // May not need this
	}
	return res;
}
\end{lstlisting}
\subsection{46}
\begin{enumerate}
\item
Method 1:
\begin{lstlisting}
class Solution {
public:
	vector<vector<int> > permute( vector<int> &num ) {
		vector<vector<int> > res;
		vector<int> out;
		vector<int> visited( num.size(), 0 );
		permuteDFS( num, 0, visited, out, res );
		return res;
	}
	void permuteDFS( vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int> > &res ) {
		if ( level == num.size() ) res.push_back( out );
		else {
			for ( int i = 0; i < num.size(); ++i ) {
				if ( visited[i] == 0 ) {
					visited[i] = 1;
					out.push_back( num[i] );
					permuteDFS( num, level + 1, visited, out, res );
					out.pop_back();
					visited[i] = 0;
				}
			}
		}
	}
};
\end{lstlisting}
\item
Method 2:
\begin{lstlisting}
class Solution {
public:
	vector<vector<int> > permute( vector<int> &num ) {
		vector<vector<int> > res;
		permuteDFS( num, 0, res );
		return res;
	}
	void permuteDFS( vector<int> &num, int start, vector<vector<int> > &res ) {
		if ( start >= num.size() ) res.push_back( num );
		for ( int i = start; i < num.size(); ++i ) {
			swap( num[start], num[i] );
			permuteDFS( num, start + 1, res );
			swap( num[start], num[i] );
		}
	}
};
\end{lstlisting}
\end{enumerate}

\subsection{47}
\begin{enumerate}
\item
Method 1:
\begin{lstlisting}
class Solution {
public:
	vector<vector<int> > permuteUnique( vector<int> &num ) {
		vector<vector<int> > res;
		vector<int> out;
		vector<int> visited( num.size(), 0 );
		sort( num.begin(), num.end() );
		permuteUniqueDFS( num, 0, visited, out, res );
		return res;
	}
	void permuteUniqueDFS( vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int> > &res ) {
		if ( level >= num.size() ) res.push_back( out );
		else {
			for ( int i = 0; i < num.size(); ++i ) {
				if ( visited[i] == 0 ) {
					if ( i > 0 && num[i] == num[i - 1] && visited[i - 1] == 0 ) continue;
					visited[i] = 1;
					out.push_back( num[i] );
					permuteUniqueDFS( num, level + 1, visited, out, res );
					out.pop_back();
					visited[i] = 0;
				}
			}
		}
	}
};
\end{lstlisting}
\item
Method 2:
\begin{lstlisting}
class Solution {
public:
	vector<vector<int>> permuteUnique( vector<int>& nums ) {
		set<vector<int>> res;
		permute( nums, 0, res );
		return vector<vector<int>>( res.begin(), res.end() );
	}
	void permute( vector<int> &nums, int start, set<vector<int>> &res ) {
		if ( start >= nums.size() ) res.insert( nums );
		for ( int i = start; i < nums.size(); ++i ) {
			if ( i != start && nums[i] == nums[start] ) continue;
			swap( nums[i], nums[start] );
			permute( nums, start + 1, res );
			swap( nums[i], nums[start] );
		}
	}
};
\end{lstlisting}
\end{enumerate}

\subsection{48}
\begin{lstlisting}
void rotate( vector<vector<int> > &matrix ) {
	int n = matrix.size();
	for ( int i = 0; i < n; ++i ) {
		for ( int j = i + 1; j < n; ++j ) {
			swap( matrix[i][j], matrix[j][i] );
		}
		reverse( matrix[i].begin(), matrix[i].end() );
	}
}
\end{lstlisting}

\subsection{49}
\begin{lstlisting}
vector<string> anagrams( vector<string> &strs ) {
	vector<string> res;
	unordered_map<string, int> m;
	for ( int i = 0; i < strs.size(); ++i ) {
		string s = strs[i];
		sort( s.begin(), s.end() );
		if ( m.find( s ) == m.end() ) {
			m[s] = i;
		}
		else {
			if ( m[s] >= 0 ) {
				res.push_back( strs[m[s]] );
				m[s] = -1;
			}
			res.push_back( strs[i] );
		}
	}
	return res;
}
\end{lstlisting}

\end{document}