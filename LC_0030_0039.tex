\documentclass[12pt,a4paper]{article}
\usepackage{charter}
%\usepackage[latin1]{inputenc}
\usepackage[left=1.50cm, right=1.50cm, top=1.20cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{textcomp}
\renewcommand{\baselinestretch}{1.5}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\usepackage{float}
\usepackage{CJKutf8}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,    
%	%   rulecolor=,
%	language=[GNU]C++,
%	basicstyle=\scriptsize,
%	upquote=true,
%	aboveskip={1.5\baselineskip},
%	columns=fixed,
%	showstringspaces=false,
%	extendedchars=false,
%	breaklines=true,
%	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%	frame=single,
%	numbers=left,
%	showtabs=false,
%	showspaces=false,
%	showstringspaces=false,
%	identifierstyle=\ttfamily,
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color[rgb]{0.026,0.112,0.095},
%	stringstyle=\color[rgb]{0.627,0.126,0.941},
%	numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%	%        \lstdefinestyle{C++}{language=C++,style=numbers}?.
%}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,
%	language=C++,
%	captionpos=b,
%	tabsize=3,
%	frame=lines,
%	numbers=left,
%	numberstyle=\tiny,
%	numbersep=5pt,
%	breaklines=true,
%	showstringspaces=false,
%	basicstyle=\footnotesize,
%	%  identifierstyle=\color{magenta},
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color{Darkgreen},
%	stringstyle=\color{red}
%}

\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	aboveskip={1.2\baselineskip},
	breaklines=true,
	frame=lines,
	numbers=left,
	xleftmargin=\parindent,
	language=C++,
	showstringspaces=false,
	basicstyle=\sffamily,%,\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
}



\lstset{escapechar=@,style=customc}

\begin{document}
\section{30}
\begin{CJK}{UTF8}{gbsn}
这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让我们找出串联给定所有单词的子串的起始位置，还是蛮有难度的一道题。这道题我们需要用到两个哈希表，第一个哈希表先把所有的单词存进去，然后从开头开始一个个遍历，停止条件为当剩余字符个数小于单词集里所有字符的长度。这时候我们需要定义第二个哈希表，然后每次找出给定单词长度的子串，看其是否在第一个哈希表里，如果没有，则break，如果有，则加入第二个哈希表，但相同的词只能出现一次，如果多了，也break。如果正好匹配完给定单词集里所有的单词，则把i存入结果中
\end{CJK}
\begin{lstlisting}
vector<int> findSubstring( string s, vector<string>& words ) {
	vector<int> res;
	if ( s.empty() || words.empty() ) return res;
	int n = words.size(), m = words[0].size();
	unordered_map<string, int> m1;
	for ( auto &a : words ) ++m1[a];
	for ( int i = 0; i <= (int)s.size() - n * m; ++i ) {
		unordered_map<string, int> m2;
		int j = 0;
		for ( j = 0; j < n; ++j ) {
			string t = s.substr( i + j * m, m );
			if ( m1.find( t ) == m1.end() ) break;
			++m2[t];
			if ( m2[t] > m1[t] ) break;
		}
		if ( j == n ) res.push_back( i );
	}
	return res;
}
\end{lstlisting}

\section{31}
\begin{CJK}{UTF8}{gbsn}
这道题让我们求下一个排列顺序，有题目中给的例子可以看出来，如果给定数组是降序，则说明是全排列的最后一种情况，则下一个排列就是最初始情况，可以参见之前的博客 Permutations 全排列。我们再来看下面一个例子，有如下的一个数组
\end{CJK}
\begin{center}
\begin{tabular}{*{6}{c}}
1 & 2 & 7 & 4 & 3 & 1\\
\end{tabular}
\end{center}
\begin{CJK}{UTF8}{gbsn}
下一个排列为：
\end{CJK}
\begin{center}
\begin{tabular}{*{6}{c}}
1 & 3 & 1 & 2 & 4 & 7\\
\end{tabular}
\end{center}
\begin{CJK}{UTF8}{gbsn}
那么是如何得到的呢，我们通过观察原数组可以发现，如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后我们再从后往前找第一个比2大的数字，是3，那么我们交换2和3，再把此时3后面的所有数字转置一下即可，步骤如下：
\end{CJK}
\begin{center}
\begin{tabular}{*{6}{c}}
1 & [2] & 7 & 4 & 3 & 1\\
1 & [3] & 7 & 4 & [2] & 1\\
1 & 3 & [1] & [2] & [4] & [7]\\
\end{tabular}
\end{center}
\begin{lstlisting}
void nextPermutation( vector<int> &num ) {
	int i, j, n = num.size();
	for ( i = n - 2; i >= 0; --i ) {
		if ( num[i + 1] > num[i] ) {
			for ( j = n - 1; j >= i; --j ) {
				if ( num[j] > num[i] ) break;
			}
			swap( num[i], num[j] );
			reverse( num.begin() + i + 1, num.end() );
			return;
		}
	}
	reverse( num.begin(), num.end() );
}
\end{lstlisting}


\section{32}
\begin{CJK}{UTF8}{gbsn}
这道求最长有效括号比之前那道 Valid Parentheses 验证括号难度要大一些，这里我们还是借助栈来求解，需要定义个start变量来记录合法括号串的起始位置，我们遍历字符串，如果遇到左括号，则将当前下标压入栈，如果遇到右括号，如果当前栈为空，则将下一个坐标位置记录到start，如果栈不为空，则将栈顶元素取出，此时若栈为空，则更新结果和i $-$ start $+$ 1中的较大值，否则更新结果和i $-$ 栈顶元素中的较大值
\end{CJK}
\begin{lstlisting}
int longestValidParentheses( string s ) {
	int res = 0, start = 0;
	stack<int> m;
	for ( int i = 0; i < s.size(); ++i ) {
		if ( s[i] == '(' ) m.push( i );
		else if ( s[i] == ')' ) {
			if ( m.empty() ) start = i + 1;
			else {
				m.pop();
				res = m.empty() ? max( res, i - start + 1 ) : max( res, i - m.top() );
			}
		}
	}
	return res;
}
\end{lstlisting}

\section{33}
\begin{CJK}{UTF8}{gbsn}
这道题让在旋转数组中搜索一个给定值，若存在返回坐标，若不存在返回$-1$。我们还是考虑二分搜索法，但是这道题的难点在于我们不知道原数组在哪旋转了，我们还是用题目中给的例子来分析，对于数组[0 1 2 4 5 6 7] 共有下列七种旋转方法：
\end{CJK}
\begin{center}
\begin{tabular}{*{7}{c}}
0 & 1 & 2 & \textcolor{red}{4} & \textcolor{red}{5} & \textcolor{red}{6} & \textcolor{red}{7} \\
7 & 0 & 1 & \textcolor{red}{2} & \textcolor{red}{4} & \textcolor{red}{5} & \textcolor{red}{6} \\
6 & 7 & 0 & \textcolor{red}{1} & \textcolor{red}{2} & \textcolor{red}{4} & \textcolor{red}{5} \\
5 & 6 & 7 & \textcolor{red}{0} & \textcolor{red}{1} & \textcolor{red}{2} & \textcolor{red}{4} \\
\textcolor{red}{4} & \textcolor{red}{5} & \textcolor{red}{6} & \textcolor{red}{7} & 0 & 1 & 2 \\
\textcolor{red}{2} & \textcolor{red}{4} & \textcolor{red}{5} & \textcolor{red}{6} & 7 & 0 & 1 \\
\textcolor{red}{1} & \textcolor{red}{2} & \textcolor{red}{4} & \textcolor{red}{5} & 6 & 7 & 0 \\
\end{tabular}
\end{center}
\begin{CJK}{UTF8}{gbsn}
二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们观察上面红色的数字都是升序的，由此我们可以观察出规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了
\end{CJK}
\begin{lstlisting}
int search( int A[], int n, int target ) {
	if ( n == 0 ) return -1;
	int left = 0, right = n - 1;
	while ( left <= right ) {
		int mid = (left + right) / 2;
		if ( A[mid] == target ) return mid;
		else if ( A[mid] < A[right] ) {
			if ( A[mid] < target && A[right] >= target ) left = mid + 1;
			else right = mid - 1;
		}
		else {
			if ( A[left] <= target && A[mid] > target ) right = mid - 1;
			else left = mid + 1;
		}
	}
	return -1;
}
\end{lstlisting}


\section{34}
\begin{CJK}{UTF8}{gbsn}
使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可
\end{CJK}
\begin{lstlisting}
vector<int> searchRange( vector<int>& nums, int target ) {
	vector<int> res( 2, -1 );
	int left = 0, right = nums.size() - 1;
	while ( left < right ) {
		int mid = left + (right - left) / 2;
		if ( nums[mid] < target ) left = mid + 1;
		else right = mid;
	}
	if ( nums[right] != target ) return res;
	res[0] = right;
	right = nums.size();
	while ( left < right ) {
		int mid = left + (right - left) / 2;
		if ( nums[mid] <= target ) left = mid + 1;
		else right = mid;
	}
	res[1] = left - 1;
	return res;
}
\end{lstlisting}

\section{35}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题基本没有什么难度，实在不理解为啥还是Medium难度的，完完全全的应该是Easy啊，三行代码搞定的题，只需要遍历一遍原数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可
\end{CJK}
\begin{lstlisting}
int searchInsert( vector<int>& nums, int target ) {
	for ( int i = 0; i < nums.size(); ++i ) {
		if ( nums[i] >= target ) return i;
	}
	return nums.size();
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
当然，我们还可以用二分搜索法来优化我们的时间复杂度，而且个人认为这种方法应该是面试官们想要考察的算法吧
\end{CJK}
\begin{lstlisting}
int searchInsert( vector<int>& nums, int target ) {
	if ( nums.back() < target ) return nums.size();
	int left = 0, right = nums.size() - 1;
	while ( left < right ) {
		int mid = left + (right - left) / 2;
		if ( nums[mid] == target ) return mid;
		else if ( nums[mid] < target ) left = mid + 1;
		else right = mid;
	}
	return right;
}
\end{lstlisting}
\end{enumerate}

\section{36}
\begin{CJK}{UTF8}{gbsn}
这道题让我们验证一个方阵是否为数独矩阵，判断标准是看各行各列是否有重复数字，以及每个小的$3\times3$的小方阵里面是否有重复数字，如果都无重复，则当前矩阵是数独矩阵，但不代表待数独矩阵有解，只是单纯的判断当前未填完的矩阵是否是数独矩阵。那么根据数独矩阵的定义，我们在遍历每个数字的时候，就看看包含当前位置的行和列以及$3\times3$小方阵中是否已经出现该数字，那么我们需要三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下
\end{CJK}
\begin{lstlisting}
bool isValidSudoku( vector<vector<char> > &board ) {
	if ( board.empty() || board[0].empty() ) return false;
	int m = board.size(), n = board[0].size();
	vector<vector<bool> > rowFlag( m, vector<bool>( n, false ) );
	vector<vector<bool> > colFlag( m, vector<bool>( n, false ) );
	vector<vector<bool> > cellFlag( m, vector<bool>( n, false ) );
	for ( int i = 0; i < m; ++i ) {
		for ( int j = 0; j < n; ++j ) {
			if ( board[i][j] >= '1' && board[i][j] <= '9' ) {
				int c = board[i][j] - '1';
				if ( rowFlag[i][c] || colFlag[c][j] || cellFlag[3 * (i / 3) + j / 3][c] ) return false;
				rowFlag[i][c] = true;
				colFlag[c][j] = true;
				cellFlag[3 * (i / 3) + j / 3][c] = true;
			}
		}
	}
	return true;
}
\end{lstlisting}

\section{37}
\begin{CJK}{UTF8}{gbsn}
这道求解数独的题是在之前那道 Valid Sudoku 验证数独的基础上的延伸，之前那道题让我们验证给定的数组是否为数独数组，这道让我们求解数独数组，跟此题类似的有 Permutations 全排列，Combinations 组合项， N-Queens N皇后问题等等，其中尤其是跟 N--Queens N皇后问题的解题思路及其相似，对于每个需要填数字的格子带入1到9，每代入一个数字都判定其是否合法，如果合法就继续下一次递归，结束时把数字设回`.'，判断新加入的数字是否合法时，只需要判定当前数字是否合法，不需要判定这个数组是否为数独数组，因为之前加进的数字都是合法的，这样可以使程序更加高效一些
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	void solveSudoku( vector<vector<char> > &board ) {
		if ( board.empty() || board.size() != 9 || board[0].size() != 9 ) return;
		solveSudokuDFS( board, 0, 0 );
	}
	bool solveSudokuDFS( vector<vector<char> > &board, int i, int j ) {
		if ( i == 9 ) return true;
		if ( j >= 9 ) return solveSudokuDFS( board, i + 1, 0 );
		if ( board[i][j] == '.' ) {
			for ( int k = 1; k <= 9; ++k ) {
				board[i][j] = (char)(k + '0');
				if ( isValid( board, i, j ) ) {
					if ( solveSudokuDFS( board, i, j + 1 ) ) return true;
				}
				board[i][j] = '.';
			}
		}
		else {
			return solveSudokuDFS( board, i, j + 1 );
		}
		return false;
	}
	bool isValid( vector<vector<char> > &board, int i, int j ) {
		for ( int col = 0; col < 9; ++col ) {
			if ( col != j && board[i][j] == board[i][col] ) return false;
		}
		for ( int row = 0; row < 9; ++row ) {
			if ( row != i && board[i][j] == board[row][j] ) return false;
		}
		for ( int row = i / 3 * 3; row < i / 3 * 3 + 3; ++row ) {
			for ( int col = j / 3 * 3; col < j / 3 * 3 + 3; ++col ) {
				if ( (row != i || col != j) && board[i][j] == board[row][col] ) return false;
			}
		}
		return true;
	}
};
\end{lstlisting}

\section{38}
\begin{CJK}{UTF8}{gbsn}
这道计数和读法问题还是第一次遇到，看似挺复杂，其实仔细一看，算法很简单，就是对于前一个数，找出相同元素的个数，把个数和该元素存到新的string里
\end{CJK}
\begin{lstlisting}
string countAndSay( int n ) {
	if ( n <= 0 ) return NULL;
	string res = "1";
	for ( int i = 1; i < n; ++i ) {
		string tmp;
		res.push_back( '$' ); // Add extra char to deal with boundary
		int count = 0;
		int len = strlen( res.c_str() );
		for ( int j = 0; j < len; ++j ) {
			if ( j == 0 ) ++count;
			else {
				if ( res[j] != res[j - 1] ) {
					tmp.push_back( count + '0' );
					tmp.push_back( res[j - 1] );
					count = 1;
				}
				else ++count;
			}
		}
		res = tmp;
	}
	return res;
}
\end{lstlisting}

\section{39}
\begin{CJK}{UTF8}{gbsn}
像这种结果要求返回所有符合要求解的题十有八九都是要利用到递归，而且解题的思路都大同小异，相类似的题目有 Path Sum II 二叉树路径之和之二，Subsets II 子集合之二，Permutations 全排列，Permutations II 全排列之二，Combinations 组合项等等，如果仔细研究这些题目发现都是一个套路，都是需要另写一个递归函数，这里我们新加入三个变量，start记录当前的递归到的下标，out为一个解，res保存所有已经得到的解，每次调用新的递归函数时，此时的target要减去当前数组的的数，具体看代码如下：
\end{CJK}
\begin{lstlisting}
class Solution {
public:
vector<vector<int> > combinationSum( vector<int> &candidates, int target ) {
	vector<vector<int> > res;
	vector<int> out;
	sort( candidates.begin(), candidates.end() );
	combinationSumDFS( candidates, target, 0, out, res );
	return res;
}
void combinationSumDFS( vector<int> &candidates, int target, int start, vector<int> &out, vector<vector<int> > &res ) {
	if ( target < 0 ) return;
	else if ( target == 0 ) res.push_back( out );
	else {
		for ( int i = start; i < candidates.size(); ++i ) {
			out.push_back( candidates[i] );
			combinationSumDFS( candidates, target - candidates[i], i, out, res );
			out.pop_back();
		}
	}
}
};
\end{lstlisting}


	
	
	\section*{Solutions}
	
	\subsection*{39}
	\begin{lstlisting}
	vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
        vector<vector<int> > res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSumDFS(candidates, target, 0, out, res);
        return res;
    }
    void combinationSumDFS(vector<int> &candidates, int target, int start, vector<int> &out, vector<vector<int> > &res) {
        if (target < 0) return;
        else if (target == 0) res.push_back(out);
        else {
            for (int i = start; i < candidates.size(); ++i) {
                out.push_back(candidates[i]);
                combinationSumDFS(candidates, target - candidates[i], i, out, res);
                out.pop_back();
            }
        }
    }
	\end{lstlisting}
	
	\subsection*{38}
	\begin{lstlisting}
	    string countAndSay(int n) {
        if (n <= 0) return NULL;
        string res = "1";
        for (int i = 1; i < n; ++i) {
            string tmp;
            res.push_back('$'); // Add extra char to deal with boundary
            int count = 0;
            int len = strlen(res.c_str());
            for (int j = 0; j < len; ++j) {
                if (j == 0) ++count;
                else {
                    if (res[j] != res[j - 1]) {
                        tmp.push_back(count + '0');
                        tmp.push_back(res[j - 1]);
                        count = 1;
                    } else ++count;
                }
            }
            res = tmp;
        }
        return res;
    }
	\end{lstlisting}
	
	\subsection*{37}
	\begin{lstlisting}
	\end{lstlisting}
	
	\subsection*{36}
	\begin{lstlisting}
	\end{lstlisting}

	\subsection*{35}
	\begin{lstlisting}
	\end{lstlisting}

	\subsection*{34}
	\begin{lstlisting}
	\end{lstlisting}
	
\end{document}