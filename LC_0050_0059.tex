\documentclass[12pt,a4paper]{article}
\usepackage{charter}
%\usepackage[latin1]{inputenc}
\usepackage[left=1.50cm, right=1.50cm, top=1.20cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{textcomp}
\renewcommand{\baselinestretch}{1.5}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\usepackage{float}
\usepackage{CJKutf8}
\usepackage{textcomp}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,    
%	%   rulecolor=,
%	language=[GNU]C++,
%	basicstyle=\scriptsize,
%	upquote=true,
%	aboveskip={1.5\baselineskip},
%	columns=fixed,
%	showstringspaces=false,
%	extendedchars=false,
%	breaklines=true,
%	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%	frame=single,
%	numbers=left,
%	showtabs=false,
%	showspaces=false,
%	showstringspaces=false,
%	identifierstyle=\ttfamily,
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color[rgb]{0.026,0.112,0.095},
%	stringstyle=\color[rgb]{0.627,0.126,0.941},
%	numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%	%        \lstdefinestyle{C++}{language=C++,style=numbers}?.
%}
%\lstset{
%	backgroundcolor=\color{lbcolor},
%	tabsize=4,
%	language=C++,
%	captionpos=b,
%	tabsize=3,
%	frame=lines,
%	numbers=left,
%	numberstyle=\tiny,
%	numbersep=5pt,
%	breaklines=true,
%	showstringspaces=false,
%	basicstyle=\footnotesize,
%	%  identifierstyle=\color{magenta},
%	keywordstyle=\color[rgb]{0,0,1},
%	commentstyle=\color{Darkgreen},
%	stringstyle=\color{red}
%}

\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	aboveskip={1.2\baselineskip},
	breaklines=true,
	frame=lines,
	numbers=left,
	xleftmargin=\parindent,
	language=C++,
	showstringspaces=false,
	basicstyle=\sffamily,%,\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
	breaklines=true,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\lstdefinestyle{customasm}{
	belowcaptionskip=1\baselineskip,
	frame=L,
	xleftmargin=\parindent,
	language=[x86masm]Assembler,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}
\section{Solution}
\subsection{50}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题让我们求x的n次方，如果我们只是简单的用个for循环让x乘以自己n次的话，未免也把LeetCode上的想的太简单了，
我们可以用递归来折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，
如果此时n是偶数，直接把上次递归得到的值算个平方返回即可，如果是奇数，则还需要乘上个x的值。
还有一点需要引起我们的注意的是n有可能为负数，对于n是负数的情况，我们可以先用其绝对值计算出一个结果再取其倒数即可
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	double myPow( double x, int n ) {
		if ( n < 0 ) return 1 / power( x, -n );
		return power( x, n );
	}
	double power( double x, int n ) {
		if ( n == 0 ) return 1;
		double half = power( x, n / 2 );
		if ( n % 2 == 0 ) return half * half;
		return x * half * half;
	}
};
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
还有一种写法可以只用一个函数即可，在每次递归中就检查n的正负，然后做相应的变换即可
\end{CJK}
\begin{lstlisting}
double myPow( double x, int n ) {
	if ( n == 0 ) return 1;
	double half = myPow( x, n / 2 );
	if ( n % 2 == 0 ) return half * half;
	else if ( n > 0 ) return half * half * x;
	else return half * half / x;
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
这道题还有迭代的解法，我们让i初始化为n，然后看i是否是2的倍数，是的话x乘以自己，否则res乘以x，
i每次循环缩小一半，直到为0停止循环。最后看n的正负，如果为负，返回其倒数，
\end{CJK}
\begin{lstlisting}
double myPow( double x, int n ) {
	double res = 1.0;
	for ( int i = n; i != 0; i /= 2 ) {
		if ( i % 2 != 0 ) res *= x;
		x *= x;
	}
	return n < 0 ? 1 / res : res;
}
\end{lstlisting}
\end{enumerate}


\subsection{51}
\begin{CJK}{UTF8}{gbsn}经典的N皇后问题，基本所有的算法书中都会包含的问题，
经典解法为回溯递归，一层一层的向下扫描，
需要用到一个pos数组，其中pos[i]表示第i行皇后的位置，
初始化为$-1$，然后从第0开始递归，
每一行都一次遍历各列，
判断如果在该位置放置皇后会不会有冲突，以此类推，
当到最后一行的皇后放好后，一种解法就生成了，将其存入结果res中，然后再还会继续完成搜索所有的情况
\par
判断对角线是否冲突：
\par
如果两个皇后在同一对角线，
那么$|$row1$-$row2$|$ = $|$column1$-$column2$|$，（row1，column1），（row2，column2）分别为冲突的两个皇后的位置
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	vector<vector<string> > solveNQueens( int n ) {
		vector<vector<string> > res;
		vector<int> pos( n, -1 );
		solveNQueensDFS( pos, 0, res );
		return res;
	}
	void solveNQueensDFS( vector<int> &pos, int row, vector<vector<string> > &res ) {
		int n = pos.size();
		if ( row == n ) {
			vector<string> out( n, string( n, '.' ) );
			for ( int i = 0; i < n; ++i ) {
				out[i][pos[i]] = 'Q';
			}
			res.push_back( out );
		}
		else {
			for ( int col = 0; col < n; ++col ) {
				if ( isValid( pos, row, col ) ) {
					pos[row] = col;
					solveNQueensDFS( pos, row + 1, res );
					pos[row] = -1;
				}
			}
		}
	}
	bool isValid( vector<int> &pos, int row, int col ) {
		for ( int i = 0; i < row; ++i ) {
			if ( col == pos[i] || abs( row - i ) == abs( col - pos[i] ) ) {
				return false;
			}
		}
		return true;
	}
};
\end{lstlisting}


\subsection{52}
\begin{CJK}{UTF8}{gbsn}
这道题是之前那道 N-Queens N皇后问题 的延伸，说是延伸其实我觉得两者顺序应该颠倒一样，
上一道题比这道题还要稍稍复杂一些，两者本质上没有啥区别，
都是要用回溯法Backtracking来解，
如果理解了之前那道题的思路，此题只要做很小的改动即可，
不再需要求出具体的皇后的摆法，只需要每次生成一种解法时，计数器加一即可
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	int totalNQueens( int n ) {
		int res = 0;
		vector<int> pos( n, -1 );
		totalNQueensDFS( pos, 0, res );
		return res;
	}
	void totalNQueensDFS( vector<int> &pos, int row, int &res ) {
		int n = pos.size();
		if ( row == n ) ++res;
		else {
			for ( int col = 0; col < n; ++col ) {
				if ( isValid( pos, row, col ) ) {
					pos[row] = col;
					totalNQueensDFS( pos, row + 1, res );
					pos[row] = -1;
				}
			}
		}
	}
	bool isValid( vector<int> &pos, int row, int col ) {
		for ( int i = 0; i < row; ++i ) {
			if ( col == pos[i] || abs( row - i ) == abs( col - pos[i] ) ) {
				return false;
			}
		}
		return true;
	}
};
\end{lstlisting}

\subsection{53}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
先来看$O(n)$的解法，定义两个变量res和tmp，其中res保存最终要返回的结果，即最大的子数组之和，
tmp是个临时变量，初始值为数组的第一个数，每遍历一个数字A[i]，比较tmp + A[i]和A[i]中的较大值存入tmp，
然后再把res和tmp中的较大值存入res，以此类推直到遍历完整个数组，可得到最大子数组的值存在res中
\end{CJK}
\begin{lstlisting}
int maxSubArray( vector<int>& nums ) {
	int res = nums[0], tmp = res;
	for ( int i = 1; i < nums.size(); ++i ) {
		tmp = max( tmp + nums[i], nums[i] );
		res = max( res, tmp );
	}
	return res;
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
题目还要求我们用分治法Divide and Conquer Approach来解，这个分治法的思想就类似于二分搜索法，
我们需要把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，
求出的最大值分别和左右两边得出的最大值相比较取最大的那一个
\end{CJK}
\begin{lstlisting}
// Divide and conquer approach
class Solution {
public:
	int maxSubArray( int A[], int n ) {
		return getMaxSubArray( A, 0, n - 1 );
	}
	int getMaxSubArray( int A[], int left, int right ) {
		if ( left >= right ) return A[left];
		int mid = (left + right) / 2;
		int lmax = getMaxSubArray( A, left, mid - 1 );
		int rmax = getMaxSubArray( A, mid + 1, right );
		int mmax = A[mid], tmp = A[mid];
		for ( int i = mid - 1; i >= left; --i ) {
			tmp += A[i];
			mmax = max( mmax, tmp );
		}
		tmp = mmax;
		for ( int i = mid + 1; i <= right; ++i ) {
			tmp += A[i];
			mmax = max( mmax, tmp );
		}
		return max( mmax, max( lmax, rmax ) );
	}
};
\end{lstlisting}
\end{enumerate}

\subsection{54}
\begin{CJK}{UTF8}{gbsn}
这道题让我们将一个矩阵按照螺旋顺序打印出来，我们只能一条边一条边的打印，
首先我们要从给定的$m \times n$的矩阵中算出按螺旋顺序有几个环，注意最终间的环可以是一个数字，
也可以是一行或者一列。环数的计算公式是 min(m, n) / 2，知道了环数，
我们可以对每个环的边按顺序打印，比如对于题目中给的那个例子，
个边生成的顺序是(用颜色标记了数字) Red $\rightarrow$ Green $\rightarrow$ Blue $\rightarrow$ Yellow $\rightarrow$ Black
\end{CJK}
\[
\begin{bmatrix}
	\textcolor{red}{1} & \textcolor{red}{2} & \textcolor{red}{3} \\
	\textcolor{yellow}{4} & 5 & \textcolor{green}{6} \\
	\textcolor{blue}{7} & \textcolor{blue}{8} & \textcolor{green}{9}
\end{bmatrix}
\]
\begin{CJK}{UTF8}{gbsn}
我们定义p，q为当前环的高度和宽度，当p或者q为1时，
表示最后一个环只有一行或者一列，可以跳出循环。
此题的难点在于下标的转换，如何正确的转换下标是解此题的关键，
我们可以对照着上面的$3\times3$的例子来完成下标的填写，
\end{CJK}
\begin{lstlisting}
vector<int> spiralOrder( vector<vector<int> > &matrix ) {
	vector<int> res;
	if ( matrix.empty() || matrix[0].empty() ) return res;
	int m = matrix.size(), n = matrix[0].size();
	int c = m > n ? (n + 1) / 2 : (m + 1) / 2;
	int p = m, q = n;
	for ( int i = 0; i < c; ++i, p -= 2, q -= 2 ) {
		for ( int col = i; col < i + q; ++col )
			res.push_back( matrix[i][col] );
		for ( int row = i + 1; row < i + p; ++row )
			res.push_back( matrix[row][i + q - 1] );
		if ( p == 1 || q == 1 ) break;
		for ( int col = i + q - 2; col >= i; --col )
			res.push_back( matrix[i + p - 1][col] );
		for ( int row = i + p - 2; row > i; --row )
			res.push_back( matrix[row][i] );
	}
	return res;
}
\end{lstlisting}

\subsection{55}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题说的是有一个非负整数的数组，每个数字表示在当前位置的基础上最多可以走的步数，
求判断能不能到达最后一个位置，开始我以为是必须刚好到达最后一个位置，
超过了不算，其实是理解题意有误，因为每个位置上的数字表示的是最多可以走的步数
而不是像玩大富翁一样摇骰子摇出几一定要走几步。
那么我们可以用动态规划Dynamic Programming来解，我们维护一个一位数组dp，
其中dp[i]表示走道i位置时剩余的最大步数，那么递推公式为：dp[i] = max(dp[i - 1], A[i - 1]) - 1，
如果当某一个时刻dp数组的值为负了，说明无法抵达当前位置，则直接返回false，
最后我们判断dp数组最后一位是否为非负数即可知道是否能抵达该位置，
\end{CJK}
\begin{lstlisting}
bool canJump( int A[], int n ) {
	vector<int> dp( n, 0 );
	for ( int i = 1; i < n; ++i ) {
		dp[i] = max( dp[i - 1], A[i - 1] ) - 1;
		if ( dp[i] < 0 ) return false;
	}
	return dp[n - 1] >= 0;
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
还有一种省空间的DP方法，维护一个常量maxIdx，表示最远能到达的位置，
遍历数组中每一个数字，如果当前坐标大于maxIdx或者maxIdx已经抵达最后一个位置则跳出循环，
否则就更新maxIdx的值为其和i + A[i]中的较大值，其中i + A[i]表示当前位置能到达的最大位置
\end{CJK}
\begin{lstlisting}
bool canJump( int A[], int n ) {
	int maxIdx = 0;
	for ( int i = 0; i < n; ++i ) {
		if ( i > maxIdx || maxIdx >= n - 1 ) break;
		maxIdx = max( maxIdx, i + A[i] );
	}
	return maxIdx >= n - 1;
}
\end{lstlisting}
\end{enumerate}

\subsection{56}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道和之前那道 Insert Interval 插入区间 很类似，这次题目要求我们合并区间，
之前那题明确了输入区间集是有序的，而这题没有，
所有我们首先要做的就是给区间集排序，由于我们要排序的是个结构体，
所以我们要定义自己的comparator，才能用sort来排序，
我们以start的值从小到大来排序，排完序我们就可以开始合并了，
首先把第一个区间存入结果中，然后从第二个开始遍历区间集，
如果结果中最后一个区间和遍历的当前区间无重叠，直接将当前区间存入结果中，
如果有重叠，将结果中最后一个区间的end值更新为结果中最后一个区间的end和当前end值之中的较大值，
然后继续遍历区间集，以此类推可以得到最终结果
\end{CJK}
\begin{lstlisting}
class Solution {
public:
	static bool comp( const Interval &a, const Interval &b ) {
		return (a.start < b.start);
	}
	vector<Interval> merge( vector<Interval> &intervals ) {
		vector<Interval> res;
		if ( intervals.empty() ) return res;
		sort( intervals.begin(), intervals.end(), comp );
		res.push_back( intervals[0] );
		for ( int i = 1; i < intervals.size(); ++i ) {
			if ( res.back().end >= intervals[i].start ) {
				res.back().end = max( res.back().end, intervals[i].end );
			}
			else {
				res.push_back( intervals[i] );
			}
		}
		return res;
	}
};
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
这道题还有另一种解法，这个解法直接调用了之前那道题 Insert Interval 插入区间 的函数，
由于插入的过程中也有合并的操作，所以我们可以建立一个空的集合，
然后把区间集的每一个区间当做一个新的区间插入结果中，也可以得到合并后的结果
\end{CJK}
\begin{lstlisting}
// Using insert method
class Solution {
public:
	vector<Interval> merge( vector<Interval> &intervals ) {
		vector<Interval> res;
		for ( int i = 0; i < intervals.size(); ++i ) {
			res = insert( res, intervals[i] );
		}
		return res;
	}
	vector<Interval> insert( vector<Interval> &intervals, Interval newInterval ) {
		vector<Interval> res = intervals;
		vector<Interval>::iterator it = res.begin();
		int overlap = 0;
		while ( it != res.end() ) {
			if ( newInterval.end < it->start ) break;
			else if ( newInterval.start > it->end ) {}
			else {
				newInterval.start = min( newInterval.start, it->start );
				newInterval.end = max( newInterval.end, it->end );
				++overlap;
			}
			++it;
		}
		if ( overlap != 0 ) it = res.erase( it - overlap, it );
		res.insert( it, newInterval );
		return res;
	}
};
\end{lstlisting}
\end{enumerate}

\subsection{57}
\begin{enumerate}
\item
\begin{CJK}{UTF8}{gbsn}
这道题让我们在一系列非重叠的区间中插入一个新的区间，可能还需要和原有的区间合并，
那么我们需要对给区间集一个一个的遍历比较，那么会有两种情况，重叠或是不重叠，
不重叠的情况最好，直接将新区间插入到对应的位置即可，重叠的情况比较复杂，
有时候会有多个重叠，我们需要更新新区间的范围以便包含所有重叠，
而且最后处理的时候还需要删除原区间集中所有和新区间重叠的区间，然后插入新区间即可。具体思路如下：
\begin{itemize}
\item 对区间集中每个区间进行遍历
\begin{itemize}
\item 如果新区间的末尾小于当前区间的开头，则跳出循环
\item 如果新区间的开头大于当前区间的末尾，不作处理
\item 如果新区间和当前区间有重叠，则更新新区间的开头为两者最小值，新区间的末尾为两者最大值，重叠数加一
\item 指针移向下一个区间
\end{itemize}
\item 如果重叠数大于0，则删除掉所有的重叠区间
\item 插入新区间到对应的位置
\end{itemize}
\end{CJK}
\begin{lstlisting}
vector<Interval> insert( vector<Interval> &intervals, Interval newInterval ) {
	vector<Interval> res = intervals;
	int i = 0, overlap = 0, n = res.size();
	while ( i < n ) {
		if ( newInterval.end < res[i].start ) break;
		else if ( newInterval.start > res[i].end ) {}
		else {
			newInterval.start = min( newInterval.start, res[i].start );
			newInterval.end = max( newInterval.end, res[i].end );
			++overlap;
		}
		++i;
	}
	if ( overlap > 0 ) res.erase( res.begin() + i - overlap, res.begin() + i );
	res.insert( res.begin() + i - overlap, newInterval );
	return res;
}
\end{lstlisting}
\item
\begin{CJK}{UTF8}{gbsn}
对Iterator Pattern比较熟悉的也可应用Iterator来求解，本质还是一样的，只是写法略有不同
\end{CJK}
\begin{lstlisting}
vector<Interval> insert( vector<Interval> &intervals, Interval newInterval ) {
	vector<Interval> res = intervals;
	vector<Interval>::iterator it = res.begin();
	int overlap = 0;
	while ( it != res.end() ) {
		if ( newInterval.end < it->start ) break;
		else if ( newInterval.start > it->end ) {}
		else {
			newInterval.start = min( newInterval.start, it->start );
			newInterval.end = max( newInterval.end, it->end );
			++overlap;
		}
		++it;
	}

	if ( overlap != 0 ) it = res.erase( it - overlap, it );
	res.insert( it, newInterval );
	return res;
}
\end{lstlisting}
\end{enumerate}

\subsection{58}
\begin{CJK}{UTF8}{gbsn}
这道题难度不是很大。先对输入字符串做预处理，
去掉开头和结尾的空格，然后用一个计数器来累计非空格的字符串的长度，遇到空格则将计数器清零
\end{CJK}
\begin{lstlisting}
int lengthOfLastWord( const char *s ) {
	int len = strlen( s );
	int left = 0;
	int right = len - 1;
	int count = 0;
	while ( s[left] == ' ' ) ++left;
	while ( s[right] == ' ' ) --right;
	for ( int i = left; i <= right; ++i ) {
		if ( s[i] == ' ' ) count = 0;
		else ++count;
	}
	return count;
}
\end{lstlisting}

\subsection{59}
\begin{CJK}{UTF8}{gbsn}
此题跟之前那道 Spiral Matrix 螺旋矩阵 本质上没什么区别，
就相当于个类似逆运算的过程，这道题是要按螺旋的顺序来填数，
由于给定矩形是个正方形，我们计算环数时用n / 2来计算，
若n为奇数时，此时最中间的那个点没有被算在环数里，所以最后需要单独赋值，
还是下标转换问题是难点，参考之前 Spiral Matrix 螺旋矩阵 的讲解来转换下标吧，
\end{CJK}
\begin{lstlisting}
vector<vector<int> > generateMatrix( int n ) {
	vector<vector<int> > res( n, vector<int>( n, 1 ) );
	int val = 1, p = n;
	for ( int i = 0; i < n / 2; ++i, p -= 2 ) {
		for ( int col = i; col < i + p; ++col )
			res[i][col] = val++;
		for ( int row = i + 1; row < i + p; ++row )
			res[row][i + p - 1] = val++;
		for ( int col = i + p - 2; col >= i; --col )
			res[i + p - 1][col] = val++;
		for ( int row = i + p - 2; row > i; --row )
			res[row][i] = val++;
	}
	if ( n % 2 != 0 ) res[n / 2][n / 2] = val;
	return res;
}
\end{lstlisting}
\end{document}